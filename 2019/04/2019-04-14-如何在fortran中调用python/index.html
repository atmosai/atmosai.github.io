<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>如何在Fortran中调用Python | bugsuse</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="About LoveIt Theme"><link rel=prev href=https://atmosai.github.io/2019/04/2019-04-14-%E4%BD%BF%E7%94%A8cffi%E4%BB%8Epython%E8%B0%83%E7%94%A8fortran%E7%A8%8B%E5%BA%8Fpython%E8%B0%83%E7%94%A8wrf%E4%BB%A3%E7%A0%81/><link rel=next href=https://atmosai.github.io/2019/04/2019-04-16-chapter1%E6%95%B0%E6%8D%AE%E5%90%8C%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/><link rel=canonical href=https://atmosai.github.io/2019/04/2019-04-14-%E5%A6%82%E4%BD%95%E5%9C%A8fortran%E4%B8%AD%E8%B0%83%E7%94%A8python/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta property="og:title" content="如何在Fortran中调用Python"><meta property="og:description" content="Python是机器学习领域不断增长的通用语言。拥有一些非常棒的工具包，比如scikit-learn，tensorflow和pytorch。气"><meta property="og:type" content="article"><meta property="og:url" content="https://atmosai.github.io/2019/04/2019-04-14-%E5%A6%82%E4%BD%95%E5%9C%A8fortran%E4%B8%AD%E8%B0%83%E7%94%A8python/"><meta property="article:published_time" content="2019-04-14T16:53:33+08:00"><meta property="article:modified_time" content="2019-04-14T16:53:33+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何在Fortran中调用Python"><meta name=twitter:description content="Python是机器学习领域不断增长的通用语言。拥有一些非常棒的工具包，比如scikit-learn，tensorflow和pytorch。气"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"如何在Fortran中调用Python","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/atmosai.github.io\/2019\/04\/2019-04-14-%E5%A6%82%E4%BD%95%E5%9C%A8fortran%E4%B8%AD%E8%B0%83%E7%94%A8python\/"},"image":{"@type":"ImageObject","url":"https:\/\/atmosai.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"fortran, python","wordcount":3476,"url":"https:\/\/atmosai.github.io\/2019\/04\/2019-04-14-%E5%A6%82%E4%BD%95%E5%9C%A8fortran%E4%B8%AD%E8%B0%83%E7%94%A8python\/","datePublished":"2019-04-14T16:53:33\x2b08:00","dateModified":"2019-04-14T16:53:33\x2b08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":{"@type":"ImageObject","url":"https:\/\/atmosai.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/css/lib/animate/animate.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://atmosai.github.io>bugsuse</a></div><div class=navbar-menu><a class=menu-item href=https://atmosai.github.io/posts>Posts</a><a class=menu-item href=https://atmosai.github.io/atmos>Atmos</a><a class=menu-item href=https://atmosai.github.io/model>Model</a><a class=menu-item href=https://atmosai.github.io/tools>Tools</a><a class=menu-item href=https://atmosai.github.io/cheats>CheatSheet</a><a class=menu-item href=https://atmosai.github.io/tags>Tags</a><a class=menu-item href=https://atmosai.github.io/categories>Categories</a><a class=menu-item href=https://atmosai.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://atmosai.github.io>bugsuse</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://atmosai.github.io/posts>Posts</a><a class=menu-item href=https://atmosai.github.io/atmos>Atmos</a><a class=menu-item href=https://atmosai.github.io/model>Model</a><a class=menu-item href=https://atmosai.github.io/tools>Tools</a><a class=menu-item href=https://atmosai.github.io/cheats>CheatSheet</a><a class=menu-item href=https://atmosai.github.io/tags>Tags</a><a class=menu-item href=https://atmosai.github.io/categories>Categories</a><a class=menu-item href=https://atmosai.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">如何在Fortran中调用Python</h1><div class=post-meta><div class=post-meta-main><a class=author href=http://i-lightning.cn rel=author target=_blank><i class="fas fa-user-circle fa-fw"></i>bugsuse
</a>&nbsp;<span class=post-category>included in&nbsp;<i class="far fa-folder fa-fw"></i><a href=https://atmosai.github.io/categories/tools/>Tools</a>&nbsp;</span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-04-14>2019-04-14</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 3476 words&nbsp;
<i class="far fa-clock fa-fw"></i>7 min&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#正文>正文</a></li><li><a href=#faq>FAQ</a><ul><li><a href=#必须将所有python代码写入header字符串吗>必须将所有Python代码写入header字符串吗？</a></li><li><a href=#如何传递fortran数组给python>如何传递Fortran数组给Python</a></li><li><a href=#必须要在三个不同的区域定义python函数签名吗>必须要在三个不同的区域定义python函数签名吗</a></li></ul></li><li><a href=#结论>结论</a></li><li><a href=#参考链接>参考链接</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#正文>正文</a></li><li><a href=#faq>FAQ</a><ul><li><a href=#必须将所有python代码写入header字符串吗>必须将所有Python代码写入header字符串吗？</a></li><li><a href=#如何传递fortran数组给python>如何传递Fortran数组给Python</a></li><li><a href=#必须要在三个不同的区域定义python函数签名吗>必须要在三个不同的区域定义python函数签名吗</a></li></ul></li><li><a href=#结论>结论</a></li><li><a href=#参考链接>参考链接</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Python是机器学习领域不断增长的通用语言。拥有一些非常棒的工具包，比如<code>scikit-learn</code>，<code>tensorflow</code>和<code>pytorch</code>。气候模式通常是使用Fortran实现的。那么我们应该将基于Python的机器学习迁移到Fortran模型中吗？数据科学领域可能会利用HTTP API(比如Flask)封装机器学习方法，但是HTTP在紧密耦合的系统(比如气候模式)中效率太低。因此，可以选择直接从Fortran中调用Python，直接通过RAM传递气候模式的状态，而不是通过高延迟的通信层，比如HTTP。</p><a class=post-dummy-target id=正文></a><h3>正文</h3><p>有很多方法可以实现通过Python调用Fortran，但是从Fortran调用Python的方法却很少。从Fortran调用Python，可以看作是将Python代码嵌入到Fortran，但是Python的设计并不是像嵌入式语言Lua。可以通过以下三种方法实现从Fortran调用Python：</p><ul><li>Python的C语言API。这是最常用的方式，但需要实现大量的C封装代码。</li><li>基于Cython。Cython用于从Python中调用C语言，但也可以实现从C调用Python。</li><li>基于CFFI。CFFI提供了非常方便的方法可以嵌入Python代码。</li></ul><p>无论选择哪种方法，用户都需要将可执行Fortran文件链接到系统Python库，比如通过添加<code>-lpython3.6</code>到Fortran模式的Makefile文件。下面通过<code>Hello World</code>示例演示如何通过Fortran调用Python。Fortran代码保存在<code>test.f90</code>文件，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fortran data-lang=fortran><span class=c>! test.f90
</span><span class=c></span><span class=k>program </span><span class=n>call_python</span>
  <span class=k>use</span><span class=p>,</span> <span class=k>intrinsic</span> <span class=kd>::</span> <span class=nb>iso_c_binding
</span><span class=nb>  </span><span class=k>implicit </span><span class=k>none
</span><span class=k>  </span><span class=k>interface
</span><span class=k>     </span><span class=k>subroutine </span><span class=n>hello_world</span><span class=p>(</span><span class=p>)</span> <span class=k>bind</span> <span class=p>(</span><span class=n>c</span><span class=p>)</span>
     <span class=k>end </span><span class=k>subroutine </span><span class=n>hello_world</span>
  <span class=k>end </span><span class=k>interface
</span><span class=k>
</span><span class=k>  </span><span class=k>call </span><span class=n>hello_world</span><span class=p>(</span><span class=p>)</span>

<span class=k>end </span><span class=k>program </span><span class=n>call_python</span>
</code></pre></td></tr></table></div></div><p>首先导入Fortran 2003内部定义的和C语言类型互通的模块<code>iso_c_binding</code>。但使用CFFI时，我们不需要写任何C代码，CFFI会生成C类型的打包接口。下一行则定义了一个C函数<code>hello_world</code>接口，这可以在C语言中实现，但是这里我们使用Python和CFFI。最后，调用<code>hello_world</code>。</p><p>为了使用<code>hello_world</code>，我们需要构建<code>CFFI</code>标注，并保存在<code>builder.py</code>中，此代码用于创建可以链接Fortran程序的动态库：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>cffi</span>
<span class=n>ffibuilder</span> <span class=o>=</span> <span class=n>cffi</span><span class=o>.</span><span class=n>FFI</span><span class=p>(</span><span class=p>)</span>

<span class=n>header</span> <span class=o>=</span> <span class=sa></span><span class=s2>&#34;&#34;&#34;</span><span class=s2>
</span><span class=s2></span><span class=s2>extern void hello_world(void);</span><span class=s2>
</span><span class=s2></span><span class=s2>&#34;&#34;&#34;</span>

<span class=n>module</span> <span class=o>=</span> <span class=sa></span><span class=s2>&#34;&#34;&#34;</span><span class=s2>
</span><span class=s2></span><span class=s2>from my_plugin import ffi</span><span class=s2>
</span><span class=s2></span><span class=s2>import numpy as np</span><span class=s2>
</span><span class=s2></span><span class=s2>
</span><span class=s2></span><span class=s2>@ffi.def_extern()</span><span class=s2>
</span><span class=s2></span><span class=s2>def hello_world():</span><span class=s2>
</span><span class=s2></span><span class=s2>    print(</span><span class=s2>&#34;</span><span class=s2>Hello World!</span><span class=s2>&#34;</span><span class=s2>)</span><span class=s2>
</span><span class=s2></span><span class=s2>&#34;&#34;&#34;</span>

<span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=sa></span><span class=s2>&#34;</span><span class=s2>plugin.h</span><span class=s2>&#34;</span><span class=p>,</span> <span class=sa></span><span class=s2>&#34;</span><span class=s2>w</span><span class=s2>&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>header</span><span class=p>)</span>

<span class=n>ffibuilder</span><span class=o>.</span><span class=n>embedding_api</span><span class=p>(</span><span class=n>header</span><span class=p>)</span>
<span class=n>ffibuilder</span><span class=o>.</span><span class=n>set_source</span><span class=p>(</span><span class=sa></span><span class=s2>&#34;</span><span class=s2>my_plugin</span><span class=s2>&#34;</span><span class=p>,</span> <span class=sa>r</span><span class=s1>&#39;&#39;&#39;</span><span class=s1>
</span><span class=s1></span><span class=s1>    #include </span><span class=s1>&#34;</span><span class=s1>plugin.h</span><span class=s1>&#34;</span><span class=s1>
</span><span class=s1></span><span class=s1>&#39;&#39;&#39;</span><span class=p>)</span>

<span class=n>ffibuilder</span><span class=o>.</span><span class=n>embedding_init_code</span><span class=p>(</span><span class=n>module</span><span class=p>)</span>
<span class=n>ffibuilder</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=sa></span><span class=s2>&#34;</span><span class=s2>libplugin.dylib</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>verbose</span><span class=o>=</span><span class=bp>True</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>首先，我们导入<code>cffi</code>包，并且声明了<strong>外部函数接口</strong>(FFI)对象。这看起来似乎比较奇怪，这只是CFFI实现这种目的的方式。下一步，<code>header</code>字符串中包含了需要调用的函数接口的定义。<code>module</code>字符串中包含了真正需要执行的Python程序。装饰器<code>@ffi.def_extern</code>用于标记<code>hello_world</code>函数。<code>my_plugin</code>用于获取<code>ffi</code>对象。<code>def_extern</code>装饰器用于处理C类型，指针等。然后，<code>ffibuilder.embedding_api(header)</code>定义了API，<code>embedding_init_code</code>定义了Python代码。</p><p>看起来比较奇怪的是在字符串中定义Python代码，但CFFI需要以这种方式将Python代码构建为共享库对象。<code>ffibuilder.set_source</code>来设置源代码信息(?)。</p><p>然后执行以下语句创建共享库<code>libplugin.dylib</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>python builder.py
</code></pre></td></tr></table></div></div><p>然后使用下列命令编译Fortran程序:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>gfortran -o <span class=nb>test</span> -L./ -lplugin test.f90
</code></pre></td></tr></table></div></div><p>以上是在Mac OSX上创建的共享库，如果在Linux上，共享库应该以<code>.so</code>结尾。如果一切没有问题，那么就可以执行文件了:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>./test
hello world
</code></pre></td></tr></table></div></div><p>以上演示了如何使用CFFI从Fortran中调用Python程序，而不需要写任何C程序。</p><a class=post-dummy-target id=faq></a><h3>FAQ</h3><a class=post-dummy-target id=必须将所有python代码写入header字符串吗></a><h4>必须将所有Python代码写入<code>header</code>字符串吗？</h4><p>不需要这样。你可以直接在不同的Python模块中定义Python代码(比如<code>my_module.py</code>)，然后在<code>module</code>字符串的开头导入即可。比如，<code>builder.py</code>可以改为如下形式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=o>.</span><span class=o>.</span><span class=o>.</span>

<span class=n>module</span> <span class=o>=</span> <span class=sa></span><span class=s2>&#34;&#34;&#34;</span><span class=s2>
</span><span class=s2></span><span class=s2>from my_plugin import ffi</span><span class=s2>
</span><span class=s2></span><span class=s2>import my_module</span><span class=s2>
</span><span class=s2></span><span class=s2>
</span><span class=s2></span><span class=s2>@ffi.def_extern()</span><span class=s2>
</span><span class=s2></span><span class=s2>def hello_world():</span><span class=s2>
</span><span class=s2></span><span class=s2>    my_module.some_function()</span><span class=s2>
</span><span class=s2></span><span class=s2>
</span><span class=s2></span><span class=s2>&#34;&#34;&#34;</span>
<span class=o>.</span><span class=o>.</span><span class=o>.</span>
</code></pre></td></tr></table></div></div><p>这将在Python中使用可导入的形式使用Python程序。在添加到Fortran中之前，你也可以通过<code>python -c "import my_module"</code>测试一下。如果失败了，你可能需要将包含<code>my_module</code>模块的路径添加到Python的<code>sys.path</code>变量中。</p><a class=post-dummy-target id=如何传递fortran数组给python></a><h4>如何传递Fortran数组给Python</h4><p><a href=https://stackoverflow.com/questions/16276268/how-to-pass-a-numpy-array-into-a-cffi-function-and-how-to-get-one-back-out target=_blank>stack overflow page</a>回答了此问题。下面是一个示例，将代码定义在一个模块文件中，比如<code>my_module.py</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=c1># my_module.py</span>

<span class=c1># Create the dictionary mapping ctypes to np dtypes.</span>
<span class=n>ctype2dtype</span> <span class=o>=</span> <span class=p>{</span><span class=p>}</span>

<span class=c1># Integer types</span>
<span class=k>for</span> <span class=n>prefix</span> <span class=ow>in</span> <span class=p>(</span><span class=sa></span><span class=s1>&#39;</span><span class=s1>int</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa></span><span class=s1>&#39;</span><span class=s1>uint</span><span class=s1>&#39;</span><span class=p>)</span><span class=p>:</span>
    <span class=k>for</span> <span class=n>log_bytes</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span><span class=p>:</span>
        <span class=n>ctype</span> <span class=o>=</span> <span class=sa></span><span class=s1>&#39;</span><span class=si>%s</span><span class=si>%d</span><span class=s1>_t</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=n>prefix</span><span class=p>,</span> <span class=mi>8</span> <span class=o>*</span> <span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=o>*</span><span class=n>log_bytes</span><span class=p>)</span><span class=p>)</span>
        <span class=n>dtype</span> <span class=o>=</span> <span class=sa></span><span class=s1>&#39;</span><span class=si>%s</span><span class=si>%d</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=n>prefix</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=p>,</span> <span class=mi>2</span><span class=o>*</span><span class=o>*</span><span class=n>log_bytes</span><span class=p>)</span>
        <span class=c1># print( ctype )</span>
        <span class=c1># print( dtype )</span>
        <span class=n>ctype2dtype</span><span class=p>[</span><span class=n>ctype</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>dtype</span><span class=p>(</span><span class=n>dtype</span><span class=p>)</span>

<span class=c1># Floating point types</span>
<span class=n>ctype2dtype</span><span class=p>[</span><span class=sa></span><span class=s1>&#39;</span><span class=s1>float</span><span class=s1>&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>dtype</span><span class=p>(</span><span class=sa></span><span class=s1>&#39;</span><span class=s1>f4</span><span class=s1>&#39;</span><span class=p>)</span>
<span class=n>ctype2dtype</span><span class=p>[</span><span class=sa></span><span class=s1>&#39;</span><span class=s1>double</span><span class=s1>&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>dtype</span><span class=p>(</span><span class=sa></span><span class=s1>&#39;</span><span class=s1>f8</span><span class=s1>&#39;</span><span class=p>)</span>


<span class=k>def</span> <span class=nf>asarray</span><span class=p>(</span><span class=n>ffi</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>shape</span><span class=p>,</span> <span class=o>*</span><span class=o>*</span><span class=n>kwargs</span><span class=p>)</span><span class=p>:</span>
    <span class=n>length</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>prod</span><span class=p>(</span><span class=n>shape</span><span class=p>)</span>
    <span class=c1># Get the canonical C type of the elements of ptr as a string.</span>
    <span class=n>T</span> <span class=o>=</span> <span class=n>ffi</span><span class=o>.</span><span class=n>getctype</span><span class=p>(</span><span class=n>ffi</span><span class=o>.</span><span class=n>typeof</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span><span class=o>.</span><span class=n>item</span><span class=p>)</span>
    <span class=c1># print( T )</span>
    <span class=c1># print( ffi.sizeof( T ) )</span>

    <span class=k>if</span> <span class=n>T</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>ctype2dtype</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=sa></span><span class=s2>&#34;</span><span class=s2>Cannot create an array for element type: </span><span class=si>%s</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=n>T</span><span class=p>)</span>

    <span class=n>a</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>frombuffer</span><span class=p>(</span><span class=n>ffi</span><span class=o>.</span><span class=n>buffer</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=n>length</span> <span class=o>*</span> <span class=n>ffi</span><span class=o>.</span><span class=n>sizeof</span><span class=p>(</span><span class=n>T</span><span class=p>)</span><span class=p>)</span><span class=p>,</span> <span class=n>ctype2dtype</span><span class=p>[</span><span class=n>T</span><span class=p>]</span><span class=p>)</span>\
          <span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=n>shape</span><span class=p>,</span> <span class=o>*</span><span class=o>*</span><span class=n>kwargs</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>a</span>

</code></pre></td></tr></table></div></div><p><code>asarray</code>函数使用CFFI的<code>ffi</code>对象转换指针<code>ptr</code>为给定形状的numpy数组。可以使用如下形式在<code>builder.py</code>中的<code>module</code>字符串中调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=n>module</span> <span class=o>=</span> <span class=sa></span><span class=s2>&#34;&#34;&#34;</span><span class=s2>
</span><span class=s2></span><span class=s2>import my_module</span><span class=s2>
</span><span class=s2></span><span class=s2>
</span><span class=s2></span><span class=s2>@ffi.def_extern()</span><span class=s2>
</span><span class=s2></span><span class=s2>def add_one(a_ptr)</span><span class=s2>
</span><span class=s2></span><span class=s2>    a = my_module.asarray(a)</span><span class=s2>
</span><span class=s2></span><span class=s2>    a[:] += 1</span><span class=s2>
</span><span class=s2></span><span class=s2>&#34;&#34;&#34;</span>
</code></pre></td></tr></table></div></div><p><code>add_one</code>也可以定义在<code>my_module.py</code>中。最后，我们需要定义与函数相关的头文件信息，并且添加到<code>builder.py</code>的<code>header</code>字符串中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=n>header</span>  <span class=o>=</span> <span class=sa></span><span class=s2>&#34;&#34;&#34;</span><span class=s2>
</span><span class=s2></span><span class=s2>extern void add_one (double *);</span><span class=s2>
</span><span class=s2></span><span class=s2>&#34;&#34;&#34;</span>
</code></pre></td></tr></table></div></div><p>最后，在Fortran中以如下形式调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fortran data-lang=fortran><span class=k>program </span><span class=n>call_python</span>
  <span class=k>use</span><span class=p>,</span> <span class=k>intrinsic</span> <span class=kd>::</span> <span class=nb>iso_c_binding
</span><span class=nb>  </span><span class=k>implicit </span><span class=k>none
</span><span class=k>  </span><span class=k>interface
</span><span class=k>    </span><span class=k>subroutine </span><span class=n>add_one</span><span class=p>(</span><span class=n>x_c</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=k>bind</span> <span class=p>(</span><span class=n>c</span><span class=p>)</span>
        <span class=k>use </span><span class=nb>iso_c_binding
</span><span class=nb>        </span><span class=kt>integer</span><span class=p>(</span><span class=kt>c_int</span><span class=p>)</span> <span class=kd>::</span> <span class=n>n</span>
        <span class=kt>real</span><span class=p>(</span><span class=kt>c_double</span><span class=p>)</span> <span class=kd>::</span> <span class=n>x_c</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
    <span class=k>end </span><span class=k>subroutine </span><span class=n>add_one</span>
  <span class=k>end </span><span class=k>interface
</span><span class=k>  
</span><span class=k>  </span><span class=kt>real</span><span class=p>(</span><span class=kt>c_double</span><span class=p>)</span> <span class=kd>::</span> <span class=n>x</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>

  <span class=k>print</span> <span class=o>*</span><span class=p>,</span> <span class=n>x</span>
  <span class=k>call </span><span class=n>add_one</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>size</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=p>)</span>
  <span class=k>print</span> <span class=o>*</span><span class=p>,</span> <span class=n>x</span>

<span class=k>end </span><span class=k>program </span><span class=n>call_python</span>
</code></pre></td></tr></table></div></div><p>这一部分，我们介绍了如何在Fortran中嵌入Python代码块，以及如何传递数组给Fortran或从Fortran传递数组给Python。然后，有些方面还是不太方便。</p><a class=post-dummy-target id=必须要在三个不同的区域定义python函数签名吗></a><h4>必须要在三个不同的区域定义python函数签名吗</h4><p>任何要传递给Fortran的Python函数，都必须要要在三个区域进行定义。</p><ul><li>首先，必须在<code>header.h</code>中进行C头文件声明</li><li>然后，执行函数必须要在<code>builder.py</code>的<code>module</code>字符串中，或一个外部模块中</li><li>最后，Fortran代码中必须包含定义子程序的<code>interface</code>块(接口块)</li></ul><p>这对于改变Python函数来说就显得有些麻烦。比如，我们写了一个Python函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>compute_precipitation</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>Q</span><span class=p>)</span><span class=p>:</span>
    <span class=o>.</span><span class=o>.</span><span class=o>.</span>
</code></pre></td></tr></table></div></div><p>必须要在所有区域进行声明。如果我们想添加一个垂直涡度<code>W</code>作为输入参数，我们必须要修改<code>builder.py</code>以及调用Fortran的程序。显而易见，对于大的工程来说，这就变得极为麻烦。</p><p>对于一般通信而言，采用了一小部分fortran/python代码封装器。主要依赖于一个外部python模块：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=c1># module.py</span>
<span class=kn>import</span> <span class=nn>imp</span>

<span class=n>STATE</span> <span class=o>=</span> <span class=p>{</span><span class=p>}</span>


<span class=k>def</span> <span class=nf>get</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>c_ptr</span><span class=p>,</span> <span class=n>shape</span><span class=p>,</span> <span class=n>ffi</span><span class=p>)</span><span class=p>:</span>
    <span class=sa></span><span class=s2>&#34;&#34;&#34;</span><span class=s2>Copy the numpy array stored in STATE[key] to a pointer</span><span class=s2>&#34;&#34;&#34;</span>

    <span class=c1># wrap pointer in numpy array</span>
    <span class=n>fortran_arr</span> <span class=o>=</span> <span class=n>asarray</span><span class=p>(</span><span class=n>ffi</span><span class=p>,</span> <span class=n>c_ptr</span><span class=p>,</span> <span class=n>shape</span><span class=p>)</span>
    
    <span class=c1># update the numpy array in place</span>
    <span class=n>fortran_arr</span><span class=p>[</span><span class=p>:</span><span class=p>]</span> <span class=o>=</span> <span class=n>STATE</span><span class=p>[</span><span class=n>key</span><span class=p>]</span>
    

<span class=k>def</span> <span class=nf>set</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>c_ptr</span><span class=p>,</span> <span class=n>shape</span><span class=p>,</span> <span class=n>ffi</span><span class=p>)</span><span class=p>:</span>
    <span class=sa></span><span class=s2>&#34;&#34;&#34;</span><span class=s2>Call python</span><span class=s2>&#34;&#34;&#34;</span>
    <span class=n>STATE</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>asarray</span><span class=p>(</span><span class=n>ffi</span><span class=p>,</span> <span class=n>c_ptr</span><span class=p>,</span> <span class=n>shape</span><span class=p>)</span><span class=o>.</span><span class=n>copy</span><span class=p>(</span><span class=p>)</span>


<span class=k>def</span> <span class=nf>call_function</span><span class=p>(</span><span class=n>module_name</span><span class=p>,</span> <span class=n>function_name</span><span class=p>)</span><span class=p>:</span>

    <span class=c1># import the python module</span>
    <span class=kn>import</span> <span class=nn>importlib</span>
    
    <span class=n>mod</span> <span class=o>=</span> <span class=n>importlib</span><span class=o>.</span><span class=n>import_module</span><span class=p>(</span><span class=n>module_name</span><span class=p>)</span>
    
    <span class=c1># the function we want to call</span>
    <span class=n>fun</span> <span class=o>=</span> <span class=nb>getattr</span><span class=p>(</span><span class=n>mod</span><span class=p>,</span> <span class=n>function_name</span><span class=p>)</span>
    
    <span class=c1># call the function</span>
    <span class=c1># this function can edit STATE inplace</span>
    <span class=n>fun</span><span class=p>(</span><span class=n>STATE</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>全局变量<code>STATE</code>是一个包含了函数需要的所有数据的Python字典。<code>get</code>和<code>set</code>函数的功能主要就是将Fortran数组传递给<code>STATA</code>或者从<code>STATE</code>中取出Fortran数组。如果这些函数使用了Fortran/CFFI封装器，那么可以使用如下方式从Fortran中调用Python函数<code>cumulus.compute_precipitation(state_dict)</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fortran data-lang=fortran><span class=k>call </span><span class=n>set</span><span class=p>(</span><span class=s2>&#34;Q&#34;</span><span class=p>,</span> <span class=n>q</span><span class=p>)</span>
<span class=k>call </span><span class=n>set</span><span class=p>(</span><span class=s2>&#34;T&#34;</span><span class=p>,</span> <span class=n>temperature</span><span class=p>)</span>
<span class=k>call </span><span class=n>set</span><span class=p>(</span><span class=s2>&#34;ahother_arg&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>

<span class=k>call </span><span class=n>call_function</span><span class=p>(</span><span class=s2>&#34;cumulus&#34;</span><span class=p>,</span> <span class=s2>&#34;compute_precipitation&#34;</span><span class=p>)</span>

<span class=k>call </span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;prec&#34;</span><span class=p>,</span> <span class=n>prec</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>如果需要传递更多的数据给<code>compute_precipitation</code>，那么需要添加更多的<code>call set</code>命令，这可能会改变Python函数的执行。我们就不需要改变<code>builder.py</code>中的任何代码。</p><a class=post-dummy-target id=结论></a><h3>结论</h3><p>上面描述了如何传递Fortran数据给Python函数，然后再获取计算输出。为了解决频繁更改接口的问题，我们将fortran数据放到了Python模块的字典中。通过调用给定的名称来获取数据，并且将计算结果也存储到相同的字段中，然后，Fortran代码通过索引字典中正确的关键词来获取结果。Cython中使用了类似的架构，但CFFI更为方便。最重要的是，从C语言中调用Cython需要导入<code>Python.h</code>头文件，还要运行<code>Py_initialize</code>和<code>init_my_cython_module</code>函数。然而，CFFI会在后台完成这些操作。</p><p>这篇文章只是起到一个简单的指示性作用，有很多问题都没有讨论，比如如何传递Fortran字符给Python。更多的代码信息，见<a href=https://github.com/nbren12/call_py_fort target=_blank>Github</a>。</p><p>​</p><a class=post-dummy-target id=参考链接></a><h3>参考链接</h3><ol><li><a href=https://www.noahbrenowitz.com/post/calling-fortran-from-python/>https://www.noahbrenowitz.com/post/calling-fortran-from-python/</a></li></ol></div><div class=post-footer id=post-footer><div style="padding:10px 0;margin:20px auto;width:100%;font-size:16px;text-align:center"><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>打赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=/img/Wechat.jpeg alt="WeChat Pay"></a><p>微信打赏</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=/img/Alipay.jpeg alt=Alipay></a><p>支付宝打赏</p></div></div></div><div class=post-info><div class=post-info-line><div class=post-info-mod><span>The article was updated on 2019-04-14</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href="//twitter.com/share?url=https%3a%2f%2fatmosai.github.io%2f2019%2f04%2f2019-04-14-%25E5%25A6%2582%25E4%25BD%2595%25E5%259C%25A8fortran%25E4%25B8%25AD%25E8%25B0%2583%25E7%2594%25A8python%2f&text=%e5%a6%82%e4%bd%95%e5%9c%a8Fortran%e4%b8%ad%e8%b0%83%e7%94%a8Python&via=xxxx" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fatmosai.github.io%2f2019%2f04%2f2019-04-14-%25E5%25A6%2582%25E4%25BD%2595%25E5%259C%25A8fortran%25E4%25B8%25AD%25E8%25B0%2583%25E7%2594%25A8python%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fatmosai.github.io%2f2019%2f04%2f2019-04-14-%25E5%25A6%2582%25E4%25BD%2595%25E5%259C%25A8fortran%25E4%25B8%25AD%25E8%25B0%2583%25E7%2594%25A8python%2f&title=%e5%a6%82%e4%bd%95%e5%9c%a8Fortran%e4%b8%ad%e8%b0%83%e7%94%a8Python" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a><a href="//service.weibo.com/share/share.php?url=https%3a%2f%2fatmosai.github.io%2f2019%2f04%2f2019-04-14-%25E5%25A6%2582%25E4%25BD%2595%25E5%259C%25A8fortran%25E4%25B8%25AD%25E8%25B0%2583%25E7%2594%25A8python%2f&appkey=&title=%e5%a6%82%e4%bd%95%e5%9c%a8Fortran%e4%b8%ad%e8%b0%83%e7%94%a8Python" target=_blank title="Share on Weibo"><i class="fab fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://atmosai.github.io/tags/fortran/><i class="fas fa-tag fa-fw"></i>&nbsp;fortran</a>&nbsp;
</span><span class=tag><a href=https://atmosai.github.io/tags/python/><i class="fas fa-tag fa-fw"></i>&nbsp;python</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://atmosai.github.io>Home</a></span></section></div><div class=post-nav><a href=https://atmosai.github.io/2019/04/2019-04-14-%E4%BD%BF%E7%94%A8cffi%E4%BB%8Epython%E8%B0%83%E7%94%A8fortran%E7%A8%8B%E5%BA%8Fpython%E8%B0%83%E7%94%A8wrf%E4%BB%A3%E7%A0%81/ class=prev rel=prev title=使用CFFI从Python调用Fortran程序:Python调用WRF代码><i class="fas fa-angle-left fa-fw"></i>使用CFFI从Python调用Fortran程序:Python调用WRF代码</a>
<a href=https://atmosai.github.io/2019/04/2019-04-16-chapter1%E6%95%B0%E6%8D%AE%E5%90%8C%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ class=next rel=next title=Chapter1:资料同化基本概念>Chapter1:资料同化基本概念<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://atmosai.github.io target=_blank>bugsuse</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script></body></html>